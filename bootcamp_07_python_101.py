# -*- coding: utf-8 -*-
"""Bootcamp 07 - Python 101

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10y5xFwajAFt_kTU6nOkc1cg3Md3pQzTy

# **Essential Python 101**

Today we are learning Python 101 for beginners.

- variables
- data types
- data structures
- function
- control flow
- OOP

## Basic Python
python w3schools https://www.w3schools.com/python/**bold text**
"""

print("I am learning Python 101")

# comment is just a note and won't appear when you run the code
1+1
2*2
5*3 # This will only show the last line

# to show all the line use print()
print(1+1)
print(2*2)
print(5*3)

# python is just a basic calculation
1+1
2*2
5-3
print(7/2)
print(7//2) # floor division, round down the answer

pow(5,2) # 5 to the power of 2

abs(-666) # absolute, change to positive number

# modulo, return reminders of division
5%3

"""## 5 building blocks
1. variables
2. data types
3. data structures
4. function
5. control flow
6. OOP

### 1. Variables
"""

# assign variable
my_name = "toy"   # string
age = 34           # integer
gpa = 3.41         # float/real number
movie_lover = True # boolean

# Python is a case sensitive, my_NAME won't run like:
my_name

# print() can accept several inputs
print(age, gpa, movie_lover, my_name)

# over write a value
age = 34
new_age = age - 12
print(age, new_age)

s23_price = 29999
discount = 0.15 # 15% 15/100
new_s23_price = s23_price * (1-discount)

print(new_s23_price)

# remove variable
del new_s23_price

# count variable
age = 34
age += 3 # similar to age + 1
age -= 2 # similar to age - 1
age *= 2 # similar to age * 2
age /= 2 # similar to age / 2
print(age)

"""### 2. Data Types
int float str bool
"""

age = 34
gpa = 3.41
school = "Kasetsart"
movie_lover = True

# check data type
print( type(age))
print( type(gpa))
print( type(school))
print( type(movie_lover))

# convert type with int, float, str, bool
x = 100
print (x, type(x))
x = str(x)
print (x, type(x))

y = True #T=1 F=0
print(y, type(y))
y = int(y)
print(y, type(y))

z = 1
print(z, type(z))
z = bool(z)
print(z, type(z))

a = 1
print(a, type(a))
a = float(a)
print(a, type(a))

text = "I'm learning Python" # one quote within two quote is fine
text2 = ' "hahahaha" ' # two quote within one quote is fine too
print(text, text2)

# python can concat str with math operators
text = "hello"
print(text + text + text + text, text*4)

# type hint, "x: type" to suggest type for python, but can't force it
age: int = 34
my_name: str = "Toy"
gpa: float = 3.41
seafood: bool = True

"""### 3. Data Structure
1. list []
2. tuple ()
3. dictionary {}
4. set {unique} (data in set cannot be the same)

#### list
- is mutable
- has the follow methods and more
    - .append
    - .sort
    - .pop
    - .remove
    - .insert
- uses brackets [ ]
"""

# list is mutable (we can update data) // on the other hand, string is not
shopping_items = ["banana","egg","milk"]
print(shopping_items)
print(shopping_items[0])
print(shopping_items[1:])
print(len(shopping_items))

# update data in the list
shopping_items[0] = "pineapple"
shopping_items[1] = "ham cheese"
print(shopping_items)

# list method
# for .append, you don't need to assign value back to the variable
shopping_items.append("egg") # adding new item to the right
print(shopping_items)

# sort items (ascending order, A-Z)
shopping_items.sort()
print(shopping_items)

# sort items (descending order, Z-A)
shopping_items.sort(reverse = True)
print(shopping_items)

# sort with int
scores = [98,75,88,90,99]
print( "no. of student: " + str(len(scores)), 
      "total scores: " + str(sum(scores)), 
      "min score: " + str(min(scores)), 
      "max score: " + str(max(scores)) )

# to find the average (python doesn't have mean, avg, or average)
print("average score: " + str(sum(scores)/len(scores)))

# we will create our own function (it's reusable)
def mean(scores):
    return sum(scores)/len(scores)

print(len(scores),
      sum(scores),
      min(scores),
      max(scores),
      mean(scores)
          )

# .pop() remove last item in list, right most side
shopping_items.append('egg')
print(shopping_items)

shopping_items.pop()
shopping_items
print(shopping_items)

# .remove() we can specify what item to remove
shopping_items.remove("milk")
print(shopping_items)

# .insert() specify at what index do we want to insert
shopping_items.insert(1,"milk")
print(shopping_items)

# list+list

item1 = ['egg', 'milk']
item2 = ['banana', 'bread']

print(item1+item2)

"""#### tuple
- is immutable
- has very few methods
    - .count
    - .index
- best used for score data that we don't want to change, eg. username & passwords
- uses ( )
"""

# tuple() is immutable
# we cannot update new data onto the tuple
tup_items = ('egg','bread','pepsi')
tup_items[2] = 'coke' # <<< can't

# since tuple() is immutable, it has only a few methods
# eg. tuple.count, tuple.index, tuple.mro
print(tup_items)
num_egg = tup_items.count('egg')
print("There's a total of " + str(num_egg) + " eggs.")

# eg. username password
# student1, student2
s1 = ("id001","123456")
s2 = ("id002","654321")
user_pw = (s1,s2)
print(user_pw)

# tuple unpacking
# we spread out the data in s1 into 1) username and 2) password
username, password = s1

print(username, password)

# tuple unpacking for 3 values
name, age, gpa = ("John Wick",42,3.98)
print(name,age,gpa)

# tuple unpacking for 3 values doesn't work if we only call out 2 values as so:
name, age = ("John Wick",42,3.98)
print(name,age)

# Therefore programmers will fix this by using "_" to replace the value they don't need
name, age, _ = ("John Wick",42,3.98)
print(name,age)

"""#### dictionary {}
- is mutable
    - many methods eg.
    - `.key` look-up all the keys
    - `.values` look-up all the values
    - `.items` look-up both keys and values and return as tuple
    - `.get` look-up the value of the called-up key
- uses key-value pairs
    - key must be immutable
    - value can be anything
- uses {}
- when retrieving data, write the key name in "[]", not the index

---

- new key-value: 
`dictionaryName["newKey"] = "newValue"`
- delete key-value:
`del dictionaryName["keyName"]`
- update key-value:
`dictionaryName["keyName"] = valueName`
- pulling nested sets within list
`dictionaryName["keyName"][index]`
"""

# dictionary key: value pairs
course = {
    "name": "Bootcamp Data Science",
    "duration": "4 months",
    "students": 200,
    "replay": True,
    "skills": ["Google Sheets", "SQL", "R", "Python", "Stats", "ML", "Dashboard", "Data Transformation"],
}
course

# when retrieving data from dictionary, type the key name
course["name"]

# creating new keys
# dictionaryName["newKey"] = "newValue"
course["start_time"] = "9am"
course["language"] = "Thai"
course

# deleting key-value from a dictionary
del course["start_time"]
course

# updating value in dictionary
course["replay"] = False
course

# pulling nested list within dictionary, add index [] right after
course["skills"][0:3]

# pulling all the keys in a dictionary
course.keys()
# wrap it into a list
list(course.keys())

# pulling all the values in a dictionary
course.values()
# wrap it into a list
list(course.values())

# pull both keys and value, in tuple
print(course.items())
print(type(course.items()))
print(course.items())
print(type(list(course.items())))

# pull key data from dictionary
a = course.get("replay")
b = course["replay"]
print(a)
print(b)
c = course.get("Replay")
d = course["Replay"]
print(c)
print(d)

# with .get, if we mispell the key (c), it won't return an error like (d)
# tips, for not getting error



"""#### set {unique}
- only store unique values
    - if there are repeats, it won't show
- uses { }
"""

# set {unique}

courses = ["Python", "Python", "R", "SQL", "SQL","sql"]
set(courses)

"""#### Recap
- list, dictionary = mutable
- tuple, string = immutable

### 4. Function
"""

# function print(), pow(), abs()
print("hello","world")
print(pow(5,2))
print(abs(-5))

# create new function with "def" eg. greeting ()
def greeting(name):
    print("Hello! "+name)

greeting("Toy")

# create default value, so even if there's no input it'll run default
def greeting(name="Toy"):
    print("Hello! "+name+".")

greeting()

# create more than one input
def greeting(name="John",location="London"):
    print("Hello! "+name+".")
    print("He is in "+location+".")

greeting()

# change up value, if position is wrong we need to make positional mapping
greeting(location = "Tokyo", name = "Naruto")

# creating another function
def add_two_nums(num1,num2):
    print(num1+num2)

add_two_nums(2,2)

# using return, will give out value, that we can sent to a variable
def add_two_nums(num1,num2):
    print("hihi")
    return num1+num2
    print("halooo") # any cmds after return won't appear bc it ends at return

result = add_two_nums(2,2)
print(result)

# we can also add hint to the inputs in function
def add_two_nums(a: int,b: int) -> int:
    return a+b

abc = add_two_nums(2,5)
print(abc)
print(type(abc))

# work with string
text = "Hello World"

long_text = """This is a very long text.
This is a new line.""" # can write more lines

print(text)
print(long_text)

# string template: fstrings
my_name = "John Wick"
location = "London"

# create a string template where it add variable into the placeholder
# {} is a placeholder
text = f"Hi! My name is {my_name} and I live in {location}"
print(text)


# .format
# this used to be harder, the older version goes like this
"Hi! My name is {} and I live in {}".format(my_name,location)

# slicing. index starts at 0
# pulling certain data from the string

text = "a duck walks into a bar"
print(text)
print("total letters: "+str(len(text)))

print(text[0])
print(text[22])
print(text[-1]) # end of line
print(text[2:6]) # letter will goes to 6 but not include 6
print(text[-3: ]) # we can also start from the back with '-'
                    # keeping the end empty = the rest

# string is immutable (we can't update value in the str)
name = "Python" # let's say we want to change it to Cython
name[0] = "C"

# what we can do instead is
name = "Python"
name = "C" + name[1:]
print(name)

# or just over-write the variable
name = "Cython"

"""#### "method" is a function made for a specific object"""

# function vs. method
# method function that is designed for a certain data type or data structure or specific object
# string method - function that is made for str
text = "a duck walks into a bar"
text.upper() # temporary change text to uppercase
print(text) # the result will still be lowercase
# unless we need to over write the variable
text = text.upper()
print(text)

# lowercase
text = text.lower()
print(text)

# capitalize only the first letter
text = text.title()
print(text)

# changing "duck" into "lion"
text = text.replace("Duck","Lion")
print(text)

# splitting text into a list
words = text.split(" ") # syntax: variable.split("delimiter")
print(words, type(words))

# joining back the words in a list
# whatever is inside "" is used to replace the comma in the list
a = " ".join(words)
b = "-".join(words)
print(a,b)

"""### Control Flow
1. if
2. for
3. while

#### if
"""

# final exam 150 questions, pass >=120
score = 105
if score >= 120:
    print("passed")
else:
    print("failed")

# create a function from the if else loop
def grade(score):
    if score >= 120:
        return "passed"
    else:
        return "failed"

# use return instead of print so that we can assign them to a variable

result = grade(120)
print(result)

# create more than one condition with if, elif, else
def grade(score):
    if score >= 120:
        return "Excellent"
    elif score >= 100:
        return "Good"
    elif score >= 80:
        return "Okay"
    else:
        return "Need to read more!"

result = grade(79)
print(result)

# use and / or in condition
# course == data science, score >= 80 passed
# course == english, score >= 70 passed
def grade(course, score):
    if course == "english" and score >= 70:
        return "passed"
    elif course == "data science" and score >= 80:
        return "passed"
    else:
        return "failed"

grade("data science",80)

"""#### for

ทำทีละตัว ทีละ item ที่อยู่ใน data structure นั้นๆ

- for loop
- list comprehension
"""

# for loop
# if score >= 80, passed
scores = [88,90,75]

for score in scores:
    print(score-2) # we adjust the score

scores = [88,90,75]
new_scores = [] # create an empty variable
for score in scores:
    new_scores.append(score - 2)
    
print(new_scores)

# to combine everything and create a function
def grading_all(scores):
    new_scores = [] # สร้าง empty list เอาไว้เพื่อ hold data ก้อนใหม่
    for score in scores:
        new_scores.append(score + 2)
    return new_scores

grading_all([75,80,99,90,75])

# list comprehension
scores = [75,80,99,90,75]

# old way
for s in scores:
    print(s*2)

# list comprehension
new_scores = [s*2 for s in scores]
new_scores

# list comprehension
# turning first letter in name to capital letter
friends = ["toy","ink","bee","zue","yos"]
cap_friends = [f.title() for f in friends]
print(cap_friends)

[f.upper() for f in friends]

"""#### while loop

- while True: do sth, when false will exit out of the loop
- require a count to keep track of loop
"""

# while loop
count = 0
while count < 5:
    count += 1
    print("Hello")

# function input for user to interact
user_name = input("What is your name? ")

def chatbot():
    fruits = []
    while True:
        fruit = input("What fruit do you want to order? ")
        if fruit == "exit":
            return fruits
        fruits.append(fruit)

chatbot()

# HW01 - chatbot to order pizza
# HW02 - pao ying chub / rock paper scissor

# when you ask for input and need it to be in int type, you can wrap the answer as int
age = int(input("What is your age? "))
print(type(age))
print(age)

"""### OOP - Object Oriented Programming
concept ในการสร้าง object ขึ้นมา

#### Eg. Creating Class Dog
"""

# OOP - Object Oriented Programming
# Dog Class
# We're teaching python to get to know Dog

class Dog:  # class names should be capitalized
    pass    # pass means, ผ่านไปก่อน ยังไม่ต้องทำอะไร

dog = Dog()
print(dog)

# let's start
# special method: def. double underscore = dunder (__)
# init = initiate
# 1st input: conventionally use 'self' but it can actually be any characters
# 2nd input: follows by the name of the "dog"'s self
class Dog:  
    def __init__(self, name):   
        self.name = name

# creating 3 dogs

dog1 = Dog("ovaltine")
dog2 = Dog("milo")
dog3 = Dog("pepsi")

dog1

# calling out dog's name use .name, like an attribute

print(dog1.name, dog2.name, dog3.name)

# if we were to create new attributes, make sure to have it in a new line too
class Dog:
    def __init__(self,name,age,breed):
        self.name = name
        self.age = age
        self.breed = breed

dog1 = Dog("ovaltine", 2 ,"Chihuahua")
dog2 = Dog("milo", 1 , "bulldog")
dog3 = Dog("pepsi", 3.5, "german shepherd")

dog1

print(dog1.name,dog1.age,dog1.breed)
print(dog2.name,dog2.age,dog2.breed)
print(dog3.name,dog3.age,dog3.breed)

dog4 = Dog("Wick",4,"assassin")

"""#### Eg. Creating Class Employee"""

class Employee:
    pass

class Employee:
    def __init__(self,id,name,dept,pos):
        self.id = id
        self.name = name
        self.dept = dept
        self.pos = pos # position
    # we want to create another function method to say hello
    def hello(self): # this is one of Employee's method
        print("Hello!")

emp1 = Employee(1,"John","Finance","Financial Analyst")
print(emp1.name,emp1.pos)

# ask for Employee to take action
emp1.hello()

# to make Employee say hello to itself
class Employee:
    def __init__(self,id,name,dept,pos):
        self.id = id
        self.name = name
        self.dept = dept
        self.pos = pos
    def hello(self):
        print(f"Hello! My name is {self.name}.") # needs bracket and cannot just use self, need attributes
    # We also want to ask him, when he wants to start work
    def work_hours(self,hours):
        print(f"{self.name} works for {hours}.") # hour doesn't need self in front because it's a new variable unrelated to class
    # We can also update department transfer
    def change_dept(self,new_dept):
        print(f"{self.name} is now in {new_dept} department." )

emp1 = Employee(1,"John","Finance","Financial Analysis")
print(emp1.name,emp1.pos)
emp1.hello()
emp1.work_hours(8)
emp1.change_dept("Data Science")

# Object: attribute => name, id, dept, pos
# Object: method => hello(), change_dept()

# HW03 - create new ATM class at least 5 methods
# ลองคิดดูว่า ATM ต้องทำอะไรบ้าง

class ATM:
    pass

# example
class ATM:
    def __init__(self,name,bank,balance):
        self.name = name
        self.bank = bank
        self.balance = balance
    def deposit(self,amt):
        self.balance += amt

scb = ATM("toyeiei","scb",500)
print(scb.balance)

scb.deposit(100)
print(scb.balance)